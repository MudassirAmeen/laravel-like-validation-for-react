{"version":3,"sources":["../src/rules.ts","../src/validator.ts"],"sourcesContent":["/**\r\n * This is custom validation library that provides flexibility just like laravel validations.\r\n * @author Mudassir Ameen\r\n */\r\n\r\nexport type ValidationRule = (value: any, data?: Record<string, any>) => string | null;\r\nexport type RuleParsed = { name: RuleName; args?: any[] };\r\n\r\nexport const ruleNames = [\r\n    \"required\",\r\n    \"nullable\",\r\n    \"email\",\r\n    \"string\",\r\n    \"numeric\",\r\n    \"integer\",\r\n    \"boolean\",\r\n    \"min\",\r\n    \"max\",\r\n    \"between\",\r\n    \"confirmed\",\r\n    \"same\",\r\n    \"regex\",\r\n    \"url\",\r\n    \"date\",\r\n    \"after\",\r\n    \"before\",\r\n    \"alpha\",\r\n    \"alpha_num\",\r\n    \"in\",\r\n    \"not_in\",\r\n    \"size\",\r\n    \"digits\",\r\n    \"digits_between\",\r\n    \"starts_with\",\r\n    \"ends_with\",\r\n] as const;\r\n\r\nexport type RuleName = typeof ruleNames[number];\r\n\r\n/**\r\n * predefinedRules: map of ruleName => factory that returns ValidationRule.\r\n * Har function k return value aik function hai jo value or data pass kar kay error ya null return karti hai.\r\n */\r\nexport const predefinedRules: Record<RuleName, (...args: any[]) => ValidationRule> = {\r\n    required: () => (value) =>\r\n        value === undefined || value === null || value === \"\" ? \"This field is required.\" : null,\r\n\r\n    nullable: () => () => null, // Server-side meaning: allow null; we handle logic in validate by skipping other rules if value is null/empty depending on 'nullable'\r\n\r\n    email: () => (value) => {\r\n        if (value === undefined || value === null || value === \"\") return \"Invalid email address.\";\r\n        const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n        return re.test(value) ? null : \"Invalid email address.\";\r\n    },\r\n\r\n    string: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"string\" ? null : \"The field must be a string.\",\r\n\r\n    numeric: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"number\" || !Number.isNaN(Number(value))\r\n            ? null\r\n            : \"The field must be numeric.\",\r\n\r\n    integer: () => (value) => (Number.isInteger(Number(value)) ? null : \"The field must be an integer.\"),\r\n\r\n    boolean: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"boolean\" || value === 0 || value === 1\r\n            ? null\r\n            : \"The field must be boolean.\",\r\n\r\n    min: (minLen: number) => (value) => {\r\n        if (value === undefined || value === null) return `Must be at least ${minLen} characters.`;\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length >= Number(minLen) ? null : `Must be at least ${minLen} characters.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) >= Number(minLen) ? null : `Must be at least ${minLen}.`;\r\n        }\r\n        return `Must be at least ${minLen}.`;\r\n    },\r\n\r\n    max: (maxLen: number) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length <= Number(maxLen) ? null : `Must be no more than ${maxLen} characters.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) <= Number(maxLen) ? null : `Must be no more than ${maxLen}.`;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    between: (minVal: number, maxVal: number) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        if (!Number.isNaN(Number(value))) {\r\n            const n = Number(value);\r\n            return n >= Number(minVal) && n <= Number(maxVal) ? null : `Must be between ${minVal} and ${maxVal}.`;\r\n        }\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            const l = value.length;\r\n            return l >= Number(minVal) && l <= Number(maxVal) ? null : `Length must be between ${minVal} and ${maxVal}.`;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    confirmed: (field: string) => (value, data) => {\r\n        // Laravel: password_confirm field convention password_confirmation\r\n        const confirmedField = `${field}_confirmation`;\r\n        if (!data) return `Fields do not match.`;\r\n        return data[confirmedField] === value ? null : \"Fields do not match.\";\r\n    },\r\n\r\n    same: (otherField: string) => (value, data) => {\r\n        if (!data) return \"Fields do not match.\";\r\n        return data[otherField] === value ? null : \"Fields do not match.\";\r\n    },\r\n\r\n    regex: (pattern: string) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        const re = new RegExp(pattern);\r\n        return re.test(String(value)) ? null : \"Invalid format.\";\r\n    },\r\n\r\n    url: () => (value) => {\r\n        if (!value) return null;\r\n        try {\r\n            // eslint-disable-next-line no-new\r\n            new URL(String(value));\r\n            return null;\r\n        } catch {\r\n            return \"Invalid URL.\";\r\n        }\r\n    },\r\n\r\n    date: () => (value) => {\r\n        if (!value) return null;\r\n        const d = Date.parse(String(value));\r\n        return !Number.isNaN(d) ? null : \"Invalid date.\";\r\n    },\r\n\r\n    after: (dateOrField: string) => (value, data) => {\r\n        if (!value) return null;\r\n        const candidate = Date.parse(String(value));\r\n        if (!Number.isNaN(candidate)) {\r\n            const compare = Date.parse(String(dateOrField));\r\n            if (!Number.isNaN(compare)) return candidate > compare ? null : `Date must be after ${dateOrField}.`;\r\n            return null;\r\n        }\r\n        // if dateOrField is another field name\r\n        if (data && data[dateOrField]) {\r\n            const other = Date.parse(String(data[dateOrField]));\r\n            return candidate > other ? null : `Date must be after ${dateOrField}.`;\r\n        }\r\n        return \"Invalid date.\";\r\n    },\r\n\r\n    before: (dateOrField: string) => (value, data) => {\r\n        if (!value) return null;\r\n        const candidate = Date.parse(String(value));\r\n        if (!Number.isNaN(candidate)) {\r\n            const compare = Date.parse(String(dateOrField));\r\n            if (!Number.isNaN(compare)) return candidate < compare ? null : `Date must be before ${dateOrField}.`;\r\n            return null;\r\n        }\r\n        if (data && data[dateOrField]) {\r\n            const other = Date.parse(String(data[dateOrField]));\r\n            return candidate < other ? null : `Date must be before ${dateOrField}.`;\r\n        }\r\n        return \"Invalid date.\";\r\n    },\r\n\r\n    alpha: () => (value) => (!value || /^[A-Za-z]+$/.test(String(value)) ? null : \"Only alphabetic characters allowed.\"),\r\n\r\n    alpha_num: () => (value) => (!value || /^[A-Za-z0-9]+$/.test(String(value)) ? null : \"Only alphanumeric characters allowed.\"),\r\n\r\n    in: (...list: string[]) => (value) => (list.includes(String(value)) ? null : `Value must be one of: ${list.join(\", \")}.`),\r\n\r\n    not_in: (...list: string[]) => (value) => (!list.includes(String(value)) ? null : `Invalid value.`),\r\n\r\n    size: (expected: number) => (value) => {\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length === Number(expected) ? null : `Length must be ${expected}.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) === Number(expected) ? null : `Value must be ${expected}.`;\r\n        }\r\n        return `Value must be ${expected}.`;\r\n    },\r\n\r\n    digits: (count: number) => (value) => (/^\\d+$/.test(String(value)) && String(value).length === Number(count) ? null : `Must be ${count} digits.`),\r\n\r\n    digits_between: (minD: number, maxD: number) => (value) => {\r\n        if (!/^\\d+$/.test(String(value))) return \"Must be digits.\";\r\n        const l = String(value).length;\r\n        return l >= Number(minD) && l <= Number(maxD) ? null : `Digits length must be between ${minD} and ${maxD}.`;\r\n    },\r\n\r\n    starts_with: (...prefixes: string[]) => (value) => {\r\n        if (!value) return null;\r\n        return prefixes.some((p) => String(value).startsWith(p)) ? null : `Must start with one of: ${prefixes.join(\", \")}`;\r\n    },\r\n\r\n    ends_with: (...suffixes: string[]) => (value) => {\r\n        if (!value) return null;\r\n        return suffixes.some((s) => String(value).endsWith(s)) ? null : `Must end with one of: ${suffixes.join(\", \")}`;\r\n    },\r\n};\r\n\r\n/**\r\n * parseRuleString - parse laravel style rule string into RuleParsed array.\r\n * Example: \"required|min:8|email|in:admin,user,guest\"\r\n */\r\nexport function parseRuleString(ruleStr: string): RuleParsed[] {\r\n    if (!ruleStr) return [];\r\n    const parts = ruleStr.split(\"|\").map((p) => p.trim()).filter(Boolean);\r\n    const out: RuleParsed[] = [];\r\n    for (const p of parts) {\r\n        const [name, argString] = p.split(\":\");\r\n        const key = name as RuleName;\r\n        if (!ruleNames.includes(key)) {\r\n            // Unknown rule - include as regex (if pattern) or ignore\r\n            // We push it as name so later validator can decide.\r\n            out.push({ name: key, args: argString ? argString.split(\",\") : [] });\r\n            continue;\r\n        }\r\n        const args = argString ? argString.split(\",\").map((a) => a.trim()) : [];\r\n        out.push({ name: key, args });\r\n    }\r\n    return out;\r\n}\r\n","import { ValidationRule, parseRuleString, predefinedRules, RuleParsed, RuleName } from \"./rules\";\r\n\r\n/**\r\n * Types\r\n */\r\nexport type RulesDefinition<T extends Record<string, any>> = Partial<Record<keyof T, string | string[] | ((value: any, data?: Record<string, any>) => string | null)[]>>;\r\n\r\nexport type Errors<T> = Partial<Record<keyof T, string | null>>;\r\n\r\n/**\r\n * buildValidatorsFromString - given a field rule string or array, return array of ValidationRule\r\n */\r\nfunction buildValidators(ruleDef: string | string[] | ((v:any,d?:any)=>string|null)[], fieldName?: string) {\r\n  const validators: ValidationRule[] = [];\r\n  if (Array.isArray(ruleDef)) {\r\n    // array could be strings or functions\r\n    for (const r of ruleDef) {\r\n      if (typeof r === \"string\") {\r\n        validators.push(...buildValidatorsFromString(r, fieldName));\r\n      } else if (typeof r === \"function\") {\r\n        validators.push(r);\r\n      }\r\n    }\r\n  } else if (typeof ruleDef === \"string\") {\r\n    validators.push(...buildValidatorsFromString(ruleDef, fieldName));\r\n  }\r\n  return validators;\r\n}\r\n\r\nfunction buildValidatorsFromString(ruleStr: string, fieldName?: string) {\r\n  const parsed = parseRuleString(ruleStr);\r\n  const validators: ValidationRule[] = [];\r\n  for (const p of parsed) {\r\n    const name = p.name as RuleName;\r\n    const args = p.args || [];\r\n    if (name in predefinedRules) {\r\n      // special-case 'confirmed' uses fieldName\r\n      if (name === \"confirmed\") {\r\n        // Laravel: 'confirmed' means field_confirmation must match\r\n        validators.push(predefinedRules.confirmed(fieldName || \"\"));\r\n      } else if (name === \"same\" && args[0]) {\r\n        validators.push(predefinedRules.same(args[0]));\r\n      } else {\r\n        // convert numeric args where appropriate\r\n        const maybeNums = args.map((a) => (a !== undefined && a !== null && !isNaN(Number(a)) ? Number(a) : a));\r\n        // @ts-ignore\r\n        validators.push(predefinedRules[name](...maybeNums));\r\n      }\r\n    } else {\r\n      // unknown rule name: we can support `in:` via fallback or regex rule if provided as regex\r\n      if (name === \"in\") {\r\n        validators.push(predefinedRules.in(...(args as string[])));\r\n      } else if (name === \"not_in\") {\r\n        validators.push(predefinedRules.not_in(...(args as string[])));\r\n      } else {\r\n        // ignore unknown rule to avoid crash\r\n        // optionally we could warn in dev mode\r\n      }\r\n    }\r\n  }\r\n  return validators;\r\n}\r\n\r\n/**\r\n * validateField - validate a single field value against ruleDef\r\n * Handles 'nullable' - if a value is empty and nullable present, skip other checks.\r\n */\r\nexport function validateField<T extends Record<string, any>>(\r\n  fieldName: keyof T,\r\n  value: any,\r\n  allData: T,\r\n  ruleDef?: string | string[] | ((value: any, data?: Record<string, any>) => string | null)[]\r\n): string | null {\r\n  if (!ruleDef) return null;\r\n  // If ruleDef is a function array or string, build validators\r\n  const validators = buildValidators(ruleDef as any, String(fieldName));\r\n\r\n  // check for 'nullable' present\r\n  const hasNullable = Array.isArray(ruleDef)\r\n    ? (ruleDef as any[]).some((r) => (typeof r === \"string\" ? r.split(\"|\").includes(\"nullable\") : false))\r\n    : typeof ruleDef === \"string\" && ruleDef.split(\"|\").includes(\"nullable\");\r\n\r\n  // treat empty-ish values\r\n  const empty =\r\n    value === undefined ||\r\n    value === null ||\r\n    (typeof value === \"string\" && value.trim() === \"\") ||\r\n    (Array.isArray(value) && value.length === 0);\r\n\r\n  if (empty && hasNullable) {\r\n    return null;\r\n  }\r\n\r\n  for (const validator of validators) {\r\n    const err = validator(value, allData);\r\n    if (err) return err;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * validateAll - validate entire data object against rules map.\r\n * returns { valid, errors }\r\n */\r\nexport function validateAll<T extends Record<string, any>>(data: T, rules: RulesDefinition<T>): { valid: boolean; errors: Errors<T> } {\r\n  const errors: Errors<T> = {};\r\n  let valid = true;\r\n\r\n  for (const key in rules) {\r\n    const ruleDef = rules[key as keyof T];\r\n    const err = validateField(key as keyof T, (data as any)[key], data, ruleDef as any);\r\n    if (err) {\r\n      valid = false;\r\n      (errors as any)[key] = err;\r\n    } else {\r\n      (errors as any)[key] = null;\r\n    }\r\n  }\r\n\r\n  return { valid, errors };\r\n}\r\n"],"mappings":"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","names":[]}