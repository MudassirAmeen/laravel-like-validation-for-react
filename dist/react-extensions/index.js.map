{"version":3,"sources":["../../src/react-extensions/index.ts","../../src/react-extensions/useForm.tsx","../../src/rules.ts","../../src/validator.ts"],"sourcesContent":["export * from \"./useForm\";","import { useState, useCallback, useMemo } from \"react\";\r\nimport axios, { AxiosRequestConfig } from \"axios\";\r\nimport { validateAll, validateField as coreValidateField } from \"../validator\";\r\nimport { parseRuleString } from \"../rules\";\r\n\r\nexport type SubmitOptions = AxiosRequestConfig & {\r\n  validateBeforeSubmit?: boolean;\r\n  onSuccess?: (resp: any) => void;\r\n  onError?: (err: any) => void;\r\n};\r\n\r\nexport function useForm<T extends Record<string, any>>(\r\n  initialValues: T,\r\n  rules?: Partial<Record<keyof T, string | string[] | ((v:any,d?:any)=>string|null)[]>>\r\n) {\r\n  const [data, setData] = useState<T>(initialValues);\r\n  const [errors, setErrors] = useState<Partial<Record<keyof T, string | null>>>({});\r\n  const [processing, setProcessing] = useState(false);\r\n\r\n  // --- Build reverse dependency map: if fieldB has \"same:fieldA\" etc.,\r\n  // then fieldA change -> revalidate fieldB automatically.\r\n  const dependentsMap = useMemo(() => {\r\n    const map = new Map<keyof T, Set<keyof T>>();\r\n    if (!rules) return map;\r\n\r\n    const add = (base: keyof T, dep: keyof T) => {\r\n      if (!map.has(base)) map.set(base, new Set());\r\n      map.get(base)!.add(dep);\r\n    };\r\n\r\n    for (const key in rules) {\r\n      const field = key as keyof T;\r\n      const def = rules[field];\r\n      const list = Array.isArray(def) ? def : [def];\r\n\r\n      for (const item of list) {\r\n        if (typeof item === \"string\") {\r\n          const tokens = parseRuleString(item);\r\n          for (const t of tokens) {\r\n            // Roman Urdu: \"same:password\" ka matlab yeh field (confirmation) depends on password.\r\n            if (t.name === \"same\" && t.args?.[0]) {\r\n              add(t.args[0] as keyof T, field);\r\n            }\r\n            // Optional: date dependencies\r\n            if ((t.name === \"after\" || t.name === \"before\") && t.args?.[0]) {\r\n              add(t.args[0] as keyof T, field);\r\n            }\r\n            // Note: Laravel \"confirmed\" UI-wise hum error confirmation field par dikhana chahtay hain,\r\n            // isliye recommend \"same:password\" ko confirmation field par lagana (neeche usage).\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return map;\r\n  }, [rules]);\r\n\r\n  const setField = useCallback((key: keyof T, value: any) => {\r\n    setData((prev) => ({ ...prev, [key]: value }));\r\n  }, []);\r\n\r\n  const setMultiple = useCallback((obj: Partial<T>) => {\r\n    setData((prev) => ({ ...prev, ...obj }));\r\n  }, []);\r\n\r\n  // âœ… New: validateField that accepts an optional value override to avoid stale state.\r\n  const validateField = useCallback(\r\n    (field: keyof T, valueOverride?: any) => {\r\n      if (!rules) return null;\r\n      const ruleDef = rules[field];\r\n\r\n      // nextData banayein taa ke latest ke sath validate ho\r\n      const nextData = (valueOverride !== undefined)\r\n        ? ({ ...data, [field]: valueOverride } as T)\r\n        : data;\r\n\r\n      const valueToUse = (valueOverride !== undefined) ? valueOverride : (data as any)[field];\r\n\r\n      const err = coreValidateField(field, valueToUse, nextData, ruleDef as any);\r\n\r\n      setErrors((prev) => ({ ...(prev as any), [field]: err }));\r\n\r\n      // ðŸ”„ Auto-revalidate dependents (e.g., password change -> recheck password_confirmation)\r\n      const deps = dependentsMap.get(field);\r\n      if (deps && deps.size > 0) {\r\n        const updated: Partial<Record<keyof T, string | null>> = {};\r\n        deps.forEach((depField) => {\r\n          const depDef = rules[depField];\r\n          const depErr = coreValidateField(depField, (nextData as any)[depField], nextData, depDef as any);\r\n          updated[depField] = depErr;\r\n        });\r\n        setErrors((prev) => ({ ...(prev as any), ...updated }));\r\n      }\r\n\r\n      return err;\r\n    },\r\n    [data, rules, dependentsMap]\r\n  );\r\n\r\n  const validate = useCallback(() => {\r\n    if (!rules) return { valid: true, errors: {} as any };\r\n    const { valid, errors: v } = validateAll(data, rules as any);\r\n    setErrors(v as any);\r\n    return { valid, errors: v };\r\n  }, [data, rules]);\r\n\r\n  async function submit(method: AxiosRequestConfig[\"method\"], url: string, config?: SubmitOptions) {\r\n    if (processing) return Promise.reject(new Error(\"Already processing\"));\r\n\r\n    const validateBefore = config?.validateBeforeSubmit ?? true;\r\n    if (validateBefore && rules) {\r\n      const { valid, errors: validationErrors } = validate();\r\n      if (!valid) {\r\n        setErrors(validationErrors as any);\r\n        return Promise.reject({ validation: true, errors: validationErrors });\r\n      }\r\n    }\r\n\r\n    setProcessing(true);\r\n    try {\r\n      const axiosConfig: AxiosRequestConfig = { method, url, ...config };\r\n      if (method && [\"get\", \"delete\"].includes((method as string).toLowerCase())) {\r\n        axiosConfig.params = data;\r\n      } else {\r\n        axiosConfig.data = data;\r\n      }\r\n      const response = await axios(axiosConfig);\r\n      setProcessing(false);\r\n      setErrors({} as any);\r\n      if (config?.onSuccess) config.onSuccess(response);\r\n      return response;\r\n    } catch (err: any) {\r\n      setProcessing(false);\r\n      if (err?.response?.data?.errors) {\r\n        const serverErrors = err.response.data.errors;\r\n        const normalized: Partial<Record<keyof T, string | null>> = {};\r\n        for (const k in serverErrors) {\r\n          normalized[k as keyof T] = Array.isArray(serverErrors[k]) ? serverErrors[k][0] : serverErrors[k];\r\n        }\r\n        setErrors(normalized as any);\r\n      }\r\n      if (config?.onError) config.onError(err);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  const get = (url: string, config?: SubmitOptions) => submit(\"get\", url, config);\r\n  const post = (url: string, config?: SubmitOptions) => submit(\"post\", url, config);\r\n  const put = (url: string, config?: SubmitOptions) => submit(\"put\", url, config);\r\n  const patch = (url: string, config?: SubmitOptions) => submit(\"patch\", url, config);\r\n  const del = (url: string, config?: SubmitOptions) => submit(\"delete\", url, config);\r\n\r\n  const reset = (keys?: (keyof T)[]) => {\r\n    if (!keys) {\r\n      setData(initialValues);\r\n      setErrors({} as any);\r\n      return;\r\n    }\r\n    setData((prev) => {\r\n      const copy = { ...prev };\r\n      for (const k of keys) copy[k as keyof T] = (initialValues as any)[k];\r\n      return copy;\r\n    });\r\n    setErrors((prev) => {\r\n      const copy = { ...(prev as any) };\r\n      for (const k of keys) (copy as any)[k] = null;\r\n      return copy;\r\n    });\r\n  };\r\n\r\n  return {\r\n    data,\r\n    setData: setMultiple,\r\n    setField,\r\n    errors,\r\n    setErrors,\r\n    processing,\r\n    validateField,     // <-- updated signature (valueOverride?)\r\n    validate,\r\n    get,\r\n    post,\r\n    put,\r\n    patch,\r\n    delete: del,\r\n    reset,\r\n  };\r\n}\r\n","/**\r\n * This is custom validation library that provides flexibility just like laravel validations.\r\n * @author Mudassir Ameen\r\n */\r\n\r\nexport type ValidationRule = (value: any, data?: Record<string, any>) => string | null;\r\nexport type RuleParsed = { name: RuleName; args?: any[] };\r\n\r\nexport const ruleNames = [\r\n    \"required\",\r\n    \"nullable\",\r\n    \"email\",\r\n    \"string\",\r\n    \"numeric\",\r\n    \"integer\",\r\n    \"boolean\",\r\n    \"min\",\r\n    \"max\",\r\n    \"between\",\r\n    \"confirmed\",\r\n    \"same\",\r\n    \"regex\",\r\n    \"url\",\r\n    \"date\",\r\n    \"after\",\r\n    \"before\",\r\n    \"alpha\",\r\n    \"alpha_num\",\r\n    \"in\",\r\n    \"not_in\",\r\n    \"size\",\r\n    \"digits\",\r\n    \"digits_between\",\r\n    \"starts_with\",\r\n    \"ends_with\",\r\n] as const;\r\n\r\nexport type RuleName = typeof ruleNames[number];\r\n\r\n/**\r\n * predefinedRules: map of ruleName => factory that returns ValidationRule.\r\n * Har function k return value aik function hai jo value or data pass kar kay error ya null return karti hai.\r\n */\r\nexport const predefinedRules: Record<RuleName, (...args: any[]) => ValidationRule> = {\r\n    required: () => (value) =>\r\n        value === undefined || value === null || value === \"\" ? \"This field is required.\" : null,\r\n\r\n    nullable: () => () => null, // Server-side meaning: allow null; we handle logic in validate by skipping other rules if value is null/empty depending on 'nullable'\r\n\r\n    email: () => (value) => {\r\n        if (value === undefined || value === null || value === \"\") return \"Invalid email address.\";\r\n        const re = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n        return re.test(value) ? null : \"Invalid email address.\";\r\n    },\r\n\r\n    string: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"string\" ? null : \"The field must be a string.\",\r\n\r\n    numeric: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"number\" || !Number.isNaN(Number(value))\r\n            ? null\r\n            : \"The field must be numeric.\",\r\n\r\n    integer: () => (value) => (Number.isInteger(Number(value)) ? null : \"The field must be an integer.\"),\r\n\r\n    boolean: () => (value) =>\r\n        value === undefined || value === null || typeof value === \"boolean\" || value === 0 || value === 1\r\n            ? null\r\n            : \"The field must be boolean.\",\r\n\r\n    min: (minLen: number) => (value) => {\r\n        if (value === undefined || value === null) return `Must be at least ${minLen} characters.`;\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length >= Number(minLen) ? null : `Must be at least ${minLen} characters.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) >= Number(minLen) ? null : `Must be at least ${minLen}.`;\r\n        }\r\n        return `Must be at least ${minLen}.`;\r\n    },\r\n\r\n    max: (maxLen: number) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length <= Number(maxLen) ? null : `Must be no more than ${maxLen} characters.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) <= Number(maxLen) ? null : `Must be no more than ${maxLen}.`;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    between: (minVal: number, maxVal: number) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        if (!Number.isNaN(Number(value))) {\r\n            const n = Number(value);\r\n            return n >= Number(minVal) && n <= Number(maxVal) ? null : `Must be between ${minVal} and ${maxVal}.`;\r\n        }\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            const l = value.length;\r\n            return l >= Number(minVal) && l <= Number(maxVal) ? null : `Length must be between ${minVal} and ${maxVal}.`;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    confirmed: (field: string) => (value, data) => {\r\n        // Laravel: password_confirm field convention password_confirmation\r\n        const confirmedField = `${field}_confirmation`;\r\n        if (!data) return `Fields do not match.`;\r\n        return data[confirmedField] === value ? null : \"Fields do not match.\";\r\n    },\r\n\r\n    same: (otherField: string) => (value, data) => {\r\n        if (!data) return \"Fields do not match.\";\r\n        return data[otherField] === value ? null : \"Fields do not match.\";\r\n    },\r\n\r\n    regex: (pattern: string) => (value) => {\r\n        if (value === undefined || value === null) return null;\r\n        const re = new RegExp(pattern);\r\n        return re.test(String(value)) ? null : \"Invalid format.\";\r\n    },\r\n\r\n    url: () => (value) => {\r\n        if (!value) return null;\r\n        try {\r\n            // eslint-disable-next-line no-new\r\n            new URL(String(value));\r\n            return null;\r\n        } catch {\r\n            return \"Invalid URL.\";\r\n        }\r\n    },\r\n\r\n    date: () => (value) => {\r\n        if (!value) return null;\r\n        const d = Date.parse(String(value));\r\n        return !Number.isNaN(d) ? null : \"Invalid date.\";\r\n    },\r\n\r\n    after: (dateOrField: string) => (value, data) => {\r\n        if (!value) return null;\r\n        const candidate = Date.parse(String(value));\r\n        if (!Number.isNaN(candidate)) {\r\n            const compare = Date.parse(String(dateOrField));\r\n            if (!Number.isNaN(compare)) return candidate > compare ? null : `Date must be after ${dateOrField}.`;\r\n            return null;\r\n        }\r\n        // if dateOrField is another field name\r\n        if (data && data[dateOrField]) {\r\n            const other = Date.parse(String(data[dateOrField]));\r\n            return candidate > other ? null : `Date must be after ${dateOrField}.`;\r\n        }\r\n        return \"Invalid date.\";\r\n    },\r\n\r\n    before: (dateOrField: string) => (value, data) => {\r\n        if (!value) return null;\r\n        const candidate = Date.parse(String(value));\r\n        if (!Number.isNaN(candidate)) {\r\n            const compare = Date.parse(String(dateOrField));\r\n            if (!Number.isNaN(compare)) return candidate < compare ? null : `Date must be before ${dateOrField}.`;\r\n            return null;\r\n        }\r\n        if (data && data[dateOrField]) {\r\n            const other = Date.parse(String(data[dateOrField]));\r\n            return candidate < other ? null : `Date must be before ${dateOrField}.`;\r\n        }\r\n        return \"Invalid date.\";\r\n    },\r\n\r\n    alpha: () => (value) => (!value || /^[A-Za-z]+$/.test(String(value)) ? null : \"Only alphabetic characters allowed.\"),\r\n\r\n    alpha_num: () => (value) => (!value || /^[A-Za-z0-9]+$/.test(String(value)) ? null : \"Only alphanumeric characters allowed.\"),\r\n\r\n    in: (...list: string[]) => (value) => (list.includes(String(value)) ? null : `Value must be one of: ${list.join(\", \")}.`),\r\n\r\n    not_in: (...list: string[]) => (value) => (!list.includes(String(value)) ? null : `Invalid value.`),\r\n\r\n    size: (expected: number) => (value) => {\r\n        if (typeof value === \"string\" || Array.isArray(value)) {\r\n            return value.length === Number(expected) ? null : `Length must be ${expected}.`;\r\n        }\r\n        if (!Number.isNaN(Number(value))) {\r\n            return Number(value) === Number(expected) ? null : `Value must be ${expected}.`;\r\n        }\r\n        return `Value must be ${expected}.`;\r\n    },\r\n\r\n    digits: (count: number) => (value) => (/^\\d+$/.test(String(value)) && String(value).length === Number(count) ? null : `Must be ${count} digits.`),\r\n\r\n    digits_between: (minD: number, maxD: number) => (value) => {\r\n        if (!/^\\d+$/.test(String(value))) return \"Must be digits.\";\r\n        const l = String(value).length;\r\n        return l >= Number(minD) && l <= Number(maxD) ? null : `Digits length must be between ${minD} and ${maxD}.`;\r\n    },\r\n\r\n    starts_with: (...prefixes: string[]) => (value) => {\r\n        if (!value) return null;\r\n        return prefixes.some((p) => String(value).startsWith(p)) ? null : `Must start with one of: ${prefixes.join(\", \")}`;\r\n    },\r\n\r\n    ends_with: (...suffixes: string[]) => (value) => {\r\n        if (!value) return null;\r\n        return suffixes.some((s) => String(value).endsWith(s)) ? null : `Must end with one of: ${suffixes.join(\", \")}`;\r\n    },\r\n};\r\n\r\n/**\r\n * parseRuleString - parse laravel style rule string into RuleParsed array.\r\n * Example: \"required|min:8|email|in:admin,user,guest\"\r\n */\r\nexport function parseRuleString(ruleStr: string): RuleParsed[] {\r\n    if (!ruleStr) return [];\r\n    const parts = ruleStr.split(\"|\").map((p) => p.trim()).filter(Boolean);\r\n    const out: RuleParsed[] = [];\r\n    for (const p of parts) {\r\n        const [name, argString] = p.split(\":\");\r\n        const key = name as RuleName;\r\n        if (!ruleNames.includes(key)) {\r\n            // Unknown rule - include as regex (if pattern) or ignore\r\n            // We push it as name so later validator can decide.\r\n            out.push({ name: key, args: argString ? argString.split(\",\") : [] });\r\n            continue;\r\n        }\r\n        const args = argString ? argString.split(\",\").map((a) => a.trim()) : [];\r\n        out.push({ name: key, args });\r\n    }\r\n    return out;\r\n}\r\n","import { ValidationRule, parseRuleString, predefinedRules, RuleParsed, RuleName } from \"./rules\";\r\n\r\n/**\r\n * Types\r\n */\r\nexport type RulesDefinition<T extends Record<string, any>> = Partial<Record<keyof T, string | string[] | ((value: any, data?: Record<string, any>) => string | null)[]>>;\r\n\r\nexport type Errors<T> = Partial<Record<keyof T, string | null>>;\r\n\r\n/**\r\n * buildValidatorsFromString - given a field rule string or array, return array of ValidationRule\r\n */\r\nfunction buildValidators(ruleDef: string | string[] | ((v:any,d?:any)=>string|null)[], fieldName?: string) {\r\n  const validators: ValidationRule[] = [];\r\n  if (Array.isArray(ruleDef)) {\r\n    // array could be strings or functions\r\n    for (const r of ruleDef) {\r\n      if (typeof r === \"string\") {\r\n        validators.push(...buildValidatorsFromString(r, fieldName));\r\n      } else if (typeof r === \"function\") {\r\n        validators.push(r);\r\n      }\r\n    }\r\n  } else if (typeof ruleDef === \"string\") {\r\n    validators.push(...buildValidatorsFromString(ruleDef, fieldName));\r\n  }\r\n  return validators;\r\n}\r\n\r\nfunction buildValidatorsFromString(ruleStr: string, fieldName?: string) {\r\n  const parsed = parseRuleString(ruleStr);\r\n  const validators: ValidationRule[] = [];\r\n  for (const p of parsed) {\r\n    const name = p.name as RuleName;\r\n    const args = p.args || [];\r\n    if (name in predefinedRules) {\r\n      // special-case 'confirmed' uses fieldName\r\n      if (name === \"confirmed\") {\r\n        // Laravel: 'confirmed' means field_confirmation must match\r\n        validators.push(predefinedRules.confirmed(fieldName || \"\"));\r\n      } else if (name === \"same\" && args[0]) {\r\n        validators.push(predefinedRules.same(args[0]));\r\n      } else {\r\n        // convert numeric args where appropriate\r\n        const maybeNums = args.map((a) => (a !== undefined && a !== null && !isNaN(Number(a)) ? Number(a) : a));\r\n        // @ts-ignore\r\n        validators.push(predefinedRules[name](...maybeNums));\r\n      }\r\n    } else {\r\n      // unknown rule name: we can support `in:` via fallback or regex rule if provided as regex\r\n      if (name === \"in\") {\r\n        validators.push(predefinedRules.in(...(args as string[])));\r\n      } else if (name === \"not_in\") {\r\n        validators.push(predefinedRules.not_in(...(args as string[])));\r\n      } else {\r\n        // ignore unknown rule to avoid crash\r\n        // optionally we could warn in dev mode\r\n      }\r\n    }\r\n  }\r\n  return validators;\r\n}\r\n\r\n/**\r\n * validateField - validate a single field value against ruleDef\r\n * Handles 'nullable' - if a value is empty and nullable present, skip other checks.\r\n */\r\nexport function validateField<T extends Record<string, any>>(\r\n  fieldName: keyof T,\r\n  value: any,\r\n  allData: T,\r\n  ruleDef?: string | string[] | ((value: any, data?: Record<string, any>) => string | null)[]\r\n): string | null {\r\n  if (!ruleDef) return null;\r\n  // If ruleDef is a function array or string, build validators\r\n  const validators = buildValidators(ruleDef as any, String(fieldName));\r\n\r\n  // check for 'nullable' present\r\n  const hasNullable = Array.isArray(ruleDef)\r\n    ? (ruleDef as any[]).some((r) => (typeof r === \"string\" ? r.split(\"|\").includes(\"nullable\") : false))\r\n    : typeof ruleDef === \"string\" && ruleDef.split(\"|\").includes(\"nullable\");\r\n\r\n  // treat empty-ish values\r\n  const empty =\r\n    value === undefined ||\r\n    value === null ||\r\n    (typeof value === \"string\" && value.trim() === \"\") ||\r\n    (Array.isArray(value) && value.length === 0);\r\n\r\n  if (empty && hasNullable) {\r\n    return null;\r\n  }\r\n\r\n  for (const validator of validators) {\r\n    const err = validator(value, allData);\r\n    if (err) return err;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * validateAll - validate entire data object against rules map.\r\n * returns { valid, errors }\r\n */\r\nexport function validateAll<T extends Record<string, any>>(data: T, rules: RulesDefinition<T>): { valid: boolean; errors: Errors<T> } {\r\n  const errors: Errors<T> = {};\r\n  let valid = true;\r\n\r\n  for (const key in rules) {\r\n    const ruleDef = rules[key as keyof T];\r\n    const err = validateField(key as keyof T, (data as any)[key], data, ruleDef as any);\r\n    if (err) {\r\n      valid = false;\r\n      (errors as any)[key] = err;\r\n    } else {\r\n      (errors as any)[key] = null;\r\n    }\r\n  }\r\n\r\n  return { valid, errors };\r\n}\r\n"],"mappings":"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","names":["validateField","axios"]}